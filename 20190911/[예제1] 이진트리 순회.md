# [예제1] 이진트리 순회

- 이진 트리가 주어질 때, 트리를 순회한 결과를 출력하라

  단, 노드 번호는 1부터 N까지로 주어진다.

  입력의 예:

  5

  1 2 3

  2 4 5

  3-1-1

  4-1-1

  5-1-1

  출력의 예:

  1 2 4 5 3  //전위순회

  4 2 5 1 3  //중위순회

  4 5 2 3 1  //후위순회

- 트리를 어떻게 저장할 거냐?

- 구조체와 배열을 이용해서 트리를 저장!

  ```c++
  Tree tree[5];
  ```

- ​      left                                                                     right

- | 2    | 3    |
  | ---- | ---- |
  | 4    | 5    |
  | -1   | -1   |
  | -1   | -1   |
  | -1   | -1   |

  

- ```c++
  // 이진트리 순회
  
  //5
  //1 2 3
  //2 4 5
  //3 -1 -1
  //4 -1 -1
  //5 -1 -1
  
  #include <stdio.h>
  
  const int MAX=100;
  struct Tree{
    int left;
    int right;
    
  };
  
  Tree tree[MAX];
  
  // tree[i] = 노드 i의 정보를 담고 있음. 
  // tree[i].left = 노드 i의 왼쪽 노드 번호 
  // tree[i].right= 노드 i의 오른쪽 노드 번호
  
  
   void preorder(int x){
     //x를 루트로 하는 서브트리를 전위순회하여 출력하는 함수 
     //preorder(2);    --> 2 4 5
     
     if(tree[x].left == -1 && tree[x].right == -1){
       printf("%d ", x);
     }else{
       // Root --> Left --> Right
       
       printf("%d ", x);
       
       if(tree[x].left!=-1) preorder(tree[x].left);
       if(tree[x].right!=-1) preorder(tree[x].right);
     }
   }
  
  
    // inoreder()
    
    
    // postorder()
  int main(){
    int n;
    
    scanf("%d", &n);
    
    for(int i=0;i<n;i++){
      int a, b, c;
      
      scanf("%d %d %d", &a, &b, &c);
      
      tree[a].left=b;
      tree[a].right=c;
    }
    
    
   preorder(1);
    
    
    return 0;
  }
  ```