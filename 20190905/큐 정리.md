# 큐 [Queue]

- First In First Out(FIFO 구조)

  Queue Overflow

  1 2 3 4

  1   2 3 4 

- 먼저 삽입한 원소가 먼저 나온다.

- 들어가는 곳과 나오는 곳이 다름.

- 연산 

  - Queue.push(x)
  - Queue.pop()

- 에러

  - 큐 오버플로우
  - 큐 언더플로우(아무것도 없는데 뺴려고 하면 발생함)

## [문제] 큐 구현하기

- 다음과 같은 일을 하는 큐를 구현하라

  - Q.create(x): Q의 크기를 x로 지정한다.
  - Q.push(x): Q에 x를 삽입한다. 
  - Q.pop(): Q에서 원소 하나를 제거한다.
  - Q.front(): Q의 가장 앞에 있는 원소를 반환한다.
  - Q.size(): Q 내에 존재하는 원소의 개수를 반환한다. 

- 큐에서는 front라는 아이가 있음. (가장 앞에 있는 원소)

- ```c++
  Q.create(3);
  
  Q.push(1);
  Q.push(2);
  Q.push(3);
  Q.push(4); //overflow
  
  print Q.front(); //1
  Q.pop();
  
  print Q.front(); //2
  Q.pop();
  ```

   1 2

   2

## 큐 구현의 문제점

- 막다른 길로 가다 보면 진행이 더 이상 안 됨.

- front, rear이 계속 증가만 함.

- 앞에 공간이 텅 비어있는데 원소를 추가할 공간이 없음

- front와 rear이 계속 증가만 하고 감소를 안 함 

  ```r
          0 1 2 3 4 5 
  data            3 4
                  f r           
  ```

## 원형 큐[Circular Queue]

- 특징: 앞, 뒤가 없다 -> 공간 활용 능력이 우수함.

  ​		--> 모든 공간을 활용 가능함.

- 원형 큐의 구현

  벗어나면 앞으로 온다~~

  증가하다가 막다른 길에 다다르면 앞으로 온다.!

- front와 rear만으로는 알 수가 없음. 

- 원형 큐 구현할 떄는 원소의 개수를 front와 rear로 결정할 게 아니고 

  push 할 때마다 별도의 변수를 증가

  pop 할 때마다 별도의 변수 감소 

- front와 rear이 같이 있으면 다 차는 경우, 비어있는 경우 임.

- 별도로 원형 큐 안에 원소가 몇 개 들어 있는지 체크해야 함. 

- 직접 원소가 몇 개 들어있는지를 측정해야 함. 

