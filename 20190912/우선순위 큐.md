# 우선순위 큐

## 1. 우선순위 큐의 개념

**원소를 제거할 시, 가장 우선순위가 높은 원소를 제거**

- 넣은 순서가 관계가 없다.
- 구체적인 자료구조가 아님.

## 2. 우선순위 큐: 배열로 구현하기

**원소를 제거할 시, 가장 우선순위가 높은 원소를 제거**

​					0  1  2  3  4  5  6  7

myQueue  1  4  3  5

​                    1  4  3

​                    1  3

​                    1

5 4 3 1

- push(x): 뒤에다가 하나씩 추가함 --> O(1)

- pop(): 

  - 우선순위 제일 큰 애 찾아야 함 --> O(n)
  - 발견  시 그 아이 빼고, 뒤의 아이들을 앞으로 당겨오기 --> O(n)

  --> O(n)

## [예제2] 우선순위 큐 구현하기

**배열을 이용하여 우선순위 큐를 구현하시오**

시스템 입력

`priorityQueue myPQ;`

`myPQ.push(1);`

`myPQ.push(2);`

`myPQ.pop();`

`print myPQ.top();`

//우선 순위가 가장 높은 원소 반환 



시스템 출력

`4`

- 코드

  ```c++
  // 우선순위 큐 구현하기
  
  // myPQ.push(x)
  // myPQ.pop()
  // myPQ.top()
  
  #include <stdio.h>
  
  const int MAX= 100;
  
  struct priorityQueue{
    int data[MAX];
    int len=0;
    
    //     0 1 2 3 4 5 6 7 
    //data 1 4 3 2 4
    
    void push(int x){
      data[len++]=x;
    }
    
    void pop(){
      // 1. 우선순위가 가장 높은 원소를 찾는다.
      // 2. 그 원소를 제거하고, 뒤의 원소를 앞으로 당긴다.
      
      int myMax=-987987987, myMaxInx = -1;
      
      for(int i=0;i<len;i++){
        if(data[i] > myMax){
          myMax=data[i];
          myMaxInx=i;
        }
      }
      
      for(int i=myMaxInx;i<len;i++){
        data[i]=data[i+1];
      }
      
      len--;
    }
    
    int top(){
      int myMax=-987987987;
      
      for(int i=0;i<len;i++){
        if(data[i]>myMax){
          myMax=data[i];
        }
      }
      return myMax;
      
    }
  };
  int main(){
    priorityQueue myPQ;
    
    myPQ.push(1);
    myPQ.push(8);
    myPQ.push(7);
    myPQ.push(5);
    
    printf("%d\n", myPQ.top());  //8
    
    myPQ.pop();
    
    printf("%d\n", myPQ.top());  //7
    
    myPQ.pop();
    
    printf("%d\n", myPQ.top());  // 5
    
    myPQ.pop();
    
    printf("%d\n", myPQ.top());  // 1
  
    
    
    return 0;
  }
  ```

  

## 배열을 이용한 우선순위 큐의 비효율성

- for loop 내에서 pop 호출 시 

  -> O(n^2)의 시간복잡도 걸림...!

- 그렇다면...? 효율성을 증대시키기 위해서 무엇이 필요한가..?

- --> 트리를 사용하면 됨!!

